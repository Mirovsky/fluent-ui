using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace FluentUI.Generator
{
    public class ClassWriter
    {
        private readonly ClassBuilder _classBuilder;
        private readonly IndentedTextWriter _writer = new(new StringWriter(), "    ");
        private readonly WriterBlacklist _blacklist = new();
        private readonly PropertiesBuilder _propertiesBuilder;

        public ClassWriter(ClassBuilder classBuilder, PropertiesBuilder propertiesBuilder)
        {
            _classBuilder = classBuilder;
            _propertiesBuilder = propertiesBuilder;
        }

        public string Write()
        {
            _writer.WriteLine("// <auto-generated/>");
            _writer.WriteLine();

            _writer.WriteLine($"namespace {_classBuilder.Namespace}");
            _writer.WriteLine("{");
            _writer.Indent++;

            var orderedUsings = _classBuilder.Usings
                .OrderBy(u => u.StartsWith("System") ? 0 : 1)
                .ThenBy(u => u.Length)
                .ThenBy(u => u);
            foreach (string u in orderedUsings)
            {
                _writer.WriteLine($"using {u};");
            }
            _writer.WriteLine();

            string className = GeneratorTypeUtils.GetSafeNonGenericName(_classBuilder.Type, _classBuilder.InnerObjectName);

            _writer.WriteLine($"public static class FluentUI{className}Extensions");
            _writer.WriteLine("{");
            _writer.Indent++;

            for (int i = 0; i < _classBuilder.Methods.Count; i++)
            {
                WriteMethodForMethod(_classBuilder.Methods[i]);

                if (i < _classBuilder.Methods.Count - 1)
                {
                    _writer.WriteLine();
                }
            }

            if (_classBuilder.Properties.Count > 0)
            {
                _writer.WriteLine();
            }

            for (int i = 0; i < _classBuilder.Properties.Count; i++)
            {
                WriteMethodForProperty(_classBuilder.Properties[i]);

                if (!_blacklist.IsClassBlacklisted(className) &&
                    !_blacklist.IsPropertyBlacklisted(_classBuilder.Properties[i]) &&
                    _propertiesBuilder.HasProperty(_classBuilder.Properties[i], _classBuilder.InnerObjectName))
                {
                    _writer.WriteLine();

                    WriteBindMethodForProperty(_classBuilder.Properties[i]);
                }

                if (i < _classBuilder.Properties.Count - 1)
                {
                    _writer.WriteLine();
                }
            }

            if (_classBuilder.Events.Count > 0)
            {
                _writer.WriteLine();
            }

            for (int i = 0; i < _classBuilder.Events.Count; i++)
            {
                WriteMethodForEvent(_classBuilder.Events[i]);

                if (i < _classBuilder.Events.Count - 1)
                {
                    _writer.WriteLine();
                }
            }

            _writer.Indent--;
            _writer.WriteLine("}");

            _writer.Indent--;
            _writer.WriteLine("}");

            return _writer.InnerWriter.ToString();
        }

        private void WriteMethodForMethod(MethodInfo methodInfo)
        {
            string methodName = GeneratorNamingUtils.AdjustMethodNameToFluent(methodInfo.Name);
            string calledMethodName = methodInfo.Name;

            string methodParameters = "";
            var parameters = methodInfo.GetParameters();
            if (parameters.Length != 0)
            {
                methodParameters = ", " + string.Join(", ", parameters.Select(p => $"{GeneratorTypeUtils.GetFullTypeNameWithNesting(p.ParameterType)} {p.Name}"));
            }
            string calledMethodArguments = string.Join(", ", methodInfo.GetParameters().Select(p => p.Name));
            string genericArguments = GetGenericArguments(methodInfo.GetGenericArguments());

            _writer.WriteLine($"public static TVisualElement {methodName}<{genericArguments}>(this TVisualElement t{methodParameters}) {GetConstraints()}");
            _writer.WriteLine("{");
            _writer.Indent++;

            _writer.WriteLine($"t.{calledMethodName}({calledMethodArguments});");
            _writer.WriteLine();
            _writer.WriteLine("return t;");

            _writer.Indent--;
            _writer.WriteLine("}");
        }

        private void WriteMethodForProperty(PropertyInfo propertyInfo)
        {
            string methodName = GeneratorNamingUtils.AdjustMethodNameToFluent(propertyInfo.Name, _classBuilder.InnerObjectName);

            string genericArguments = GetGenericArguments(Array.Empty<Type>());

            string propertyType = GeneratorTypeUtils.GetFullTypeNameWithNesting(propertyInfo.PropertyType);

            string propertyNameWithInnerObject = GeneratorNamingUtils.GetPropertyName(propertyInfo.Name, _classBuilder.InnerObjectName);
            string propertyName = propertyInfo.Name;

            _writer.WriteLine($"public static TVisualElement {methodName}<{genericArguments}>(this TVisualElement t, {propertyType} {propertyName}) {GetConstraints()}");
            _writer.WriteLine("{");
            _writer.Indent++;

            _writer.WriteLine($"t.{propertyNameWithInnerObject} = {propertyName};");
            _writer.WriteLine();
            _writer.WriteLine("return t;");

            _writer.Indent--;
            _writer.WriteLine("}");
        }

        private void WriteBindMethodForProperty(PropertyInfo propertyInfo)
        {
            string methodName = GeneratorNamingUtils.AdjustMethodNameToFluent(propertyInfo.Name, _classBuilder.InnerObjectName);

            string genericArguments = GetGenericArguments(Array.Empty<Type>());

            string propertyName = GeneratorNamingUtils.GetPropertyFieldName(GeneratorNamingUtils.GetPropertyName(propertyInfo.Name, _classBuilder.InnerObjectName).Replace("Property", ""));

            _writer.WriteLine($"public static TVisualElement Bind{methodName}<{genericArguments}>(this TVisualElement t, String propertyName, object localDataSource = null, BindingMode bindingMode = BindingMode.ToTarget) {GetConstraints()}");
            _writer.WriteLine("{");
            _writer.Indent++;

            _writer.WriteLine($"t.SetBinding(Properties.{propertyName}, BindingsRepository.GetCachedOrCreateBinding(propertyName, localDataSource, bindingMode));");

            _writer.WriteLine();
            _writer.WriteLine("return t;");

            _writer.Indent--;
            _writer.WriteLine("}");
        }

        private void WriteMethodForEvent(EventInfo eventInfo)
        {
            string methodName = GeneratorNamingUtils.AdjustMethodNameToFluent(eventInfo.Name);

            string genericArguments = GetGenericArguments(Array.Empty<Type>());

            string eventType = GeneratorTypeUtils.GetFullTypeNameWithNesting(eventInfo.EventHandlerType);
            string eventName = eventInfo.Name;

            _writer.WriteLine($"public static TVisualElement {methodName}<{genericArguments}>(this TVisualElement t, {eventType} {eventName}) {GetConstraints()}");
            _writer.WriteLine("{");
            _writer.Indent++;

            _writer.WriteLine($"t.{eventName} += {eventName};");
            _writer.WriteLine();
            _writer.WriteLine("return t;");

            _writer.Indent--;
            _writer.WriteLine("}");
        }

        private string GetConstraints() => string.Join(
            " ",
            _classBuilder.GenericTypeParameters
                .Where(p => p.IsGenericParameter)
                .Select(CreateConstraint)
                .Prepend($"where TVisualElement : {GeneratorTypeUtils.GetFullTypeName(_classBuilder.Type)}")
                .Where(s => !string.IsNullOrEmpty(s))
                .ToArray()
        );

        private string GetGenericArguments(Type[] args) => string.Join(
            ", ",
            _classBuilder.GenericTypeParameters.Select(a => a.Name).Concat(args.Select(a => a.Name)).Prepend("TVisualElement")
        );

        private static string CreateConstraint(Type type)
        {
            var constraintsTypes = type.GetGenericParameterConstraints();
            if (constraintsTypes.Length == 0)
            {
                return string.Empty;
            }

            var constraints = new List<string>(type.GetGenericParameterConstraints().Select(GeneratorTypeUtils.GetFullTypeName));

            if (type.GenericParameterAttributes.HasFlag(GenericParameterAttributes.DefaultConstructorConstraint))
            {
                constraints.Add("new()");
            }

            return $"where {type.Name} : {string.Join(", ", constraints)}";
        }
    }
}
